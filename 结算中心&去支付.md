##### s9day113

## 内容回顾:

1, 路飞学成的购物车是如何实现的?

```Python
我会把用户的购物信息构造成一个特定的数据结构放在redis里面,这个结构用来支撑后面的结算功能,以及支付功能方便去拿
购物信息中的东西.
```

2, 商品是否有个数?

```Python
路飞学城的单品是没有个数的,但是有一个类似于个数的"价格策略",因为我们的价格策略具有时间周期,像我们在淘宝上买东
西的时候是有个数的,但是在路飞学成上面个数指的是时间,同一个课程买多了其实也没什么意义,因为每个课程的计时都是从
用户支付成功开始计时的.
```

3, 购物车在redis中的结构是什么样子的?

```Python
{
    "data": [  
            {
                "title": "python基础",
                "img": ".jpeg",
                "policy": {
                    "1": {
                        "period": 30,
                        "period_display": "1个月",
                        "price": 399.0
                    },
                    "2": {
                        "period": 90,
                        "period_display": "3个月",
                        "price": 599.0
                    },
                    "3": {
                        "period": 180,
                        "period_display": "6个月",
                        "price": 799.0
                    }
                },
                "default_policy": "3"
            }
        ,
            {
                "title": "爬虫",
                "img": "2.png",
                "policy": {
                    "4": {
                        "period": 180,
                        "period_display": "6个月",
                        "price": 577.0
                    }
                },
                "default_policy": "4"
            }
    ],
    "code": 1000,
    "error": null
}
```

4, 购物车购买的数量有限制吗?

```Python
.keys("xxxxx")
```

5, 购物车是否设置超时时间?

```Python
# 给购物车中的商品设置超时时间,减轻内存的压力
.conn.expire("shopping_car_1_1",60*60*24)  # 在这里不适合设置超时时间

方案:
    购买课程的个数进行限制(200个)
```

6, 为什么要把购物车信息放在redis中?

```python 
1, 临时状态,因为把商品放在购物车中就是为了去结算,结算过后还要删除,购物车就是在模拟我们在超市购物的篮子,购物
完成后,还是要还回去的.
2, 频繁修改的话,速度也会更快.
```

7, 具体购物车的逻辑?

```python 
将商品添加到购物车:
    1, 用户选择: 课程id,价格策略id,提交
    2, 获取课程,价格策略进行合法性校验 (数据库查询)
    3, 数据获取,构造结构;
    	{
            shopping_car_用户ID_课程ID:{
                title:"...",
                img:"....",
                policy:{
                    ....
                } 
            }
        }
     4, 将数据以字典的形式保存到redis中.

修改:
    1, 用户选择: 课程,价格策略,提交
    2, 获取课程,价格策略进行合法性校验(redis查询)
    3, 更新价格策略
    
删除:
    1, 用户选择: 课程提交
    2, 获取课程合法性校验(redis查询)
    3, 删除
    
查看:
    1, 构造Key	shopping_用户ID_*
    2, scan_iter
```

8, 写代码的原则(优化):

```Python
- 简单逻辑先处理
- try
	- 细粒度异常+自定义异常捕获
- 导入模块
	- 内置
    - 框架
    - 自定义
- 注释
	- 文件的注释
    - 类的注释
    - 函数的注释
- 文件名,类名,函数名,project项目名
- 对功能进行分类,整理到文件夹中 提高代码的复用性
- 减少代码层级
- BaseResponse 封装返回的对象

```

## 结算中心:

a, 添加到结算中心

```python
请求: POST
数据:
    {
        courseids:[1,2]
    }
```

b,优惠券生成记录

```Python

绑定课程的优惠券:
    满减券(大促)					  2022-07-04	 2022-07-10	
    通用优惠券(促销)				 2022-07-04		2022-07-10
未绑定:
    折扣券(微职位)				 2022-07-04		2022-07-11
    满减券(一周年)				 2022-07-04		2022-07-13
    通用券(情人节活动)			    2022-07-04		2022-07-13
# 用户ID = 1
```

c, 结算中心在redis中的最终结构

```Python
#  结算中心 -- POST请求的最终数据结构  写入redis中的数据类型是bytes
redis = {
       luffy_payment_1_1: {
            'course_id': '1',
            'title': 'python基础', 
            'img': '.jpeg', 
            'policy_id': '3', 
            'coupon': {
                "4": {"coupon_type": 2, "coupon_type_display": "\\u6298\\u6263\\u5238", "off_percent": null},
                "5": {"coupon_type": 0, "coupon_type_display": "\\u7acb\\u51cf\\u5238", "money_equivalent_value": 30}}, 
            'default_coupon': 0, 
            'period': 180, 
            'period_display': '6个月', 
            'price': 799.0
        }
        luffy_payment_1_2:{
            'course_id': '2',
            'title': '爬虫', 
            'img': '2.png', 
            'policy_id': '4', 
            'coupon': '{}',
            'default_coupon': 0, 
            'period': 180, 
            'period_display': '6个月',
            'price': 577.0
        }
        luffy_payment_coupon_1: {
            'coupon': {
                "2": {"coupon_type": 0, "coupon_type_display": "\\u7acb\\u51cf\\u5238", "money_equivalent_value": 50},
                "3": {"coupon_type": 1, "coupon_type_display": "\\u6ee1\\u51cf\\u5238", "money_equivalent_value": 10, "minimum_consume": 500}
                    }, 
            'default_coupon': 0
                            }

    }	

```

d,利用Q构建复杂查询

```Python
# 条件
con= {
    "id":1,
    "age__gt":9,
    "name__lt":8   
}
以"或"的方式查询USER表中符合条件的数据
# filter只能构造and
models.User.objects.filter(**conn)    

# 构建复杂(条件写死)
con = Q(Q(id=1)|Q(age__gt=9)|Q(name__lt=8))
models.User.objects.filter(con)

# 正确方法
# 动态构造复杂的
q1 = Q()
q1.connector = "OR"
for k, v in con.items():
    q1.children.append(k,v)
models.User.objects.filter(q1)
 

```

get

```Python
# get请求最终返回的数据   数据类型是字典
{
    "data": {
        "course_list": [
            {
                "course_id": "1",
                "price": "799.0",
                "period": "180",
                "title": "python基础",
                "default_coupon": "4",
                "img": ".jpeg",
                "policy_id": "3",
                "period_display": "6个月",
                "coupon": {
                    "4": {
                        "coupon_type": 2,
                        "coupon_type_display": "折扣券",
                        "off_percent": null
                    },
                    "5": {
                        "coupon_type": 0,
                        "coupon_type_display": "立减券",
                        "money_equivalent_value": 30
                    }
                }
            },
            {
                "course_id": "2",
                "title": "爬虫",
                "img": "2.png",
                "policy_id": "4",
                "coupon": {},
                "default_coupon": "0",
                "period": "180",
                "period_display": "6个月",
                "price": "577.0"
            }
        ],
        
        "global_coupon_dict": {
            "coupon": {
                "2": {
                    "coupon_type": 0,
                    "coupon_type_display": "立减券",
                    "money_equivalent_value": 50
                },
                "3": {
                    "coupon_type": 1,
                    "coupon_type_display": "满减券",
                    "money_equivalent_value": 10,
                    "minimum_consume": 500
                }
            },
            "default_coupon": "3"
        }
    },
    "code": 1000,
    "error": null
}
```

去支付

```Python
        """
        去支付
        :param request:
        :param args:
        :param kwargs:
        :return:
        1, 获取用户提交数据
                {
                    balance : 1000, 贝里抵扣
                    money : 900     最终支付金额
                }
            balance = request.data.get("balance")
            money = request.data.get("money")
        2, 数据验证
            - balance和money大于等于0
            - 个人账户的贝里余额是否大于等于1000贝里
            if user.auth.user.balance < balance:
                抛异常--> 账户贝里余额不足
                
        优惠券ID_list = [1,3,5]
        3, 去结算中心处理课程信息  # 目的: 计算出总价和划线价格 
            for course_dict in redis的结算中心获取:
                - 获取课程ID
                - 根据course_id去数据库中检查,此课程的状态

                - 获取价格策略
                - 根据policy_id 去数据库检查,此价格策略的状态

                - 获取用户使用的优惠券ID
                - 根据优惠券ID检查优惠券是否过期

                - 获取原价 + 获取优惠券类型
                    - 立减 :
                        判断: 优惠券金额>原价: 折后价=0
                        else:
                            划线价格 = 原价 - 优惠券金额
                    - 满减: 是否满足限制条件
                        划线价格  = 原价 - 优惠券金额
                    - 折扣:
                        划线价格  = 原价*80/100
        4. 全栈优惠券
            - 去数据库校验全站优惠券的合法性
            - 应用优惠券
                - 立减:
                    0 = 划线价格  - 优惠券金额  # 优惠券金额 > 实际支付金额
                    或
                    折后金额 = 划线价格  - 优惠券金额
                - 满减: 是否满足限制
                    折后价格 = 划线价格  - 优惠劵金额
                - 折扣:
                    折后金额 = 划线价格 *80/100
             --->实际支付金额
        5, 贝里抵扣 
        6, 总金额的校验
              实际支付 - 贝里 == money     # money是前端传过来的最终需要支付的金额     
        7, 为当前课程生成订单
            - 事务: 要成功都成功,要失败都失败, 数据库操作放在最后做统一做事务.这样就不会出现乱扣费的情况
                - 订单创建一条数据 Order  # Order表和OrderDetail表是一对多的关系,OrderDetail表存放的是一个订单中的每一个商品的详细信息
                    - 订单详细表创建一条数据 OrderDetail       EnrolledCourse
                    - 订单详细表创建一条数据 OrderDetail       EnrolledCourse 
                    - 订单详细表创建一条数据 OrderDetail       EnrolledCourse
                
                - 如果有贝里支付
                    - 贝里金额扣除    account
                    - 交易记录      TransactionRecode
                - 优惠券状态更新   CouponRecord
                
                注意:
                    如果支付宝支付金额0,表示订单状态: 已支付
                    如果支付宝支付金额110, 表示订单状态: 未支付
                        - 生成url(含订单号)
                        - 回调函数: 更新订单状态
        """
    https://www.cnblogs.com/xiao987334176/p/9487528.html  详解
        
   相关代码:
	https://github.com/987334176/luffycity/archive/v1.6.zip 
```



